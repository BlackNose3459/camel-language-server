<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>THE ACE LINE: ZETA PROTOCOL</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* Deep Black */
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            cursor: crosshair;
        }
        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }
        .hud-text {
            font-size: 20px;
            font-weight: bold;
            color: #ff0033; /* Red Signal */
            text-shadow: 0 0 5px #ff0000;
            margin-bottom: 5px;
        }
        .boss-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            display: none; /* Hidden until boss spawns */
        }
        #boss-hp-bar {
            width: 400px;
            height: 20px;
            background: #333;
            border: 2px solid #00ccff;
        }
        #boss-hp-fill {
            width: 100%;
            height: 100%;
            background: #00ccff;
            transition: width 0.1s;
        }
        
        /* Screens */
        .screen-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border: 4px solid;
        }
        #game-over { border-color: #ff0033; color: #ff0033; }
        #victory { border-color: #00ff00; color: #00ff00; }
        
        button {
            background: white;
            color: black;
            border: none;
            padding: 10px 20px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            margin-top: 20px;
        }
        button:hover { background: #ccc; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-text" id="signalDisplay">SIGNAL STRENGTH: 100%</div>
    <div class="hud-text">SCORE: <span id="scoreDisplay">0</span></div>
</div>

<div class="boss-hud" id="bossHud">
    <div style="color: #00ccff; font-size: 24px; margin-bottom: 5px;">⚠️ TARGET: ZETA ⚠️</div>
    <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
</div>

<div id="game-over" class="screen-overlay">
    <h1 style="font-size: 60px; margin: 0;">SIGNAL LOST</h1>
    <p>YOU HAVE BEEN DELETED.</p>
    <button onclick="location.reload()">REBOOT SYSTEM</button>
</div>

<div id="victory" class="screen-overlay">
    <h1 style="font-size: 60px; margin: 0;">TARGET PURGED</h1>
    <p>ZETA DESTROYED. NETWORK SECURE.</p>
    <p style="font-size: 24px;">RANK: ACE OF SPADES</p>
    <button onclick="location.reload()">NEW CONTRACT</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- GAME STATE ---
    let gameRunning = true;
    let score = 0;
    let frameCount = 0;
    let bossSpawned = false;

    // --- PLAYER ---
    const player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 25,
        speed: 5,
        color: '#ff0033', 
        health: 100,
        maxHealth: 100
    };

    // --- BOSS (ZETA) ---
    const boss = {
        active: false,
        x: -100,
        y: -100,
        size: 80,
        speed: 2,
        color: '#00ccff', // Electric Blue
        hp: 1000,
        maxHp: 1000,
        shootTimer: 0
    };

    // --- ARRAYS ---
    const bullets = []; // Player bullets
    const bossBullets = []; // Boss bullets
    const enemies = [];
    const drops = []; 

    // --- CONTROLS ---
    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.key] = true);
    window.addEventListener('keyup', (e) => keys[e.key] = false);
    window.addEventListener('mousedown', (e) => {
        if (!gameRunning) return;
        const angle = Math.atan2(e.clientY - (player.y + player.size/2), e.clientX - (player.x + player.size/2));
        bullets.push({
            x: player.x + player.size/2,
            y: player.y + player.size/2,
            dx: Math.cos(angle) * 15,
            dy: Math.sin(angle) * 15,
            size: 6,
            color: '#00ff00' 
        });
    });

    // --- SPAWNER ---
    setInterval(() => {
        if (!gameRunning) return;
        
        // Stop spawning normal enemies if Boss is active (1v1 Duel Mode)
        // OR keep them for healing? Let's keep them but slower.
        let spawnRate = boss.active ? 2000 : Math.max(200, 800 - (score / 10));
        
        // Random spawn logic handled by frame check or separate interval? 
        // Simple fix: We'll just spawn one here if condition met.
        // Actually, let's keep the logic simple:
        // This interval runs every 800ms roughly. 
    }, 1000); // Placeholder, actual spawning is below in loop

    let spawnTimer = 0;

    function update() {
        if (!gameRunning) return;
        frameCount++;

        // 1. SPAWN LOGIC
        if (score >= 1000 && !bossSpawned) {
            spawnBoss();
        }

        spawnTimer++;
        let rate = boss.active ? 100 : 60; // Spawn slower during boss
        if (spawnTimer > rate) {
            spawnEnemy();
            spawnTimer = 0;
        }

        // 2. PLAYER MOVE
        if (keys['w'] || keys['ArrowUp']) player.y -= player.speed;
        if (keys['s'] || keys['ArrowDown']) player.y += player.speed;
        if (keys['a'] || keys['ArrowLeft']) player.x -= player.speed;
        if (keys['d'] || keys['ArrowRight']) player.x += player.speed;
        player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
        player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));

        // 3. BULLETS (PLAYER)
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.dx;
            b.y += b.dy;
            if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) bullets.splice(i, 1);
        }

        // 4. DROPS
        for (let i = drops.length - 1; i >= 0; i--) {
            let d = drops[i];
            let dist = Math.hypot((player.x+player.size/2) - d.x, (player.y+player.size/2) - d.y);
            if (dist < player.size) {
                player.health = Math.min(player.maxHealth, player.health + 20);
                updateHud();
                drops.splice(i, 1);
            }
        }

        // 5. ENEMIES
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            const angle = Math.atan2(player.y - e.y, player.x - e.x);
            e.x += Math.cos(angle) * e.speed;
            e.y += Math.sin(angle) * e.speed;

            // Hit by Bullet
            for (let j = bullets.length - 1; j >= 0; j--) {
                let b = bullets[j];
                let dist = Math.hypot(b.x - (e.x+e.size/2), b.y - (e.y+e.size/2));
                if (dist < e.size/2 + b.size) {
                    if (Math.random() < 0.3) drops.push({x: e.x+e.size/2, y: e.y+e.size/2, size: 8});
                    enemies.splice(i, 1);
                    bullets.splice(j, 1);
                    score += 100;
                    updateHud();
                    return;
                }
            }
            // Hit Player
            let pDist = Math.hypot((player.x+player.size/2) - (e.x+e.size/2), (player.y+player.size/2) - (e.y+e.size/2));
            if (pDist < player.size) {
                player.health -= 10;
                enemies.splice(i, 1);
                updateHud();
                if (player.health <= 0) gameOver();
            }
        }

        // 6. BOSS LOGIC (ZETA)
        if (boss.active) {
            // Move Boss
            const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
            boss.x += Math.cos(angle) * boss.speed;
            boss.y += Math.sin(angle) * boss.speed;

            // Boss Shoots
            boss.shootTimer++;
            if (boss.shootTimer > 60) { // Shoot every 60 frames (approx 1 sec)
                bossBullets.push({
                    x: boss.x + boss.size/2,
                    y: boss.y + boss.size/2,
                    dx: Math.cos(angle) * 8, // Fast bullets
                    dy: Math.sin(angle) * 8,
                    size: 15,
                    color: '#ffffff' // White Hot Data
                });
                boss.shootTimer = 0;
            }

            // Boss Collision with Player Bullets
            for (let j = bullets.length - 1; j >= 0; j--) {
                let b = bullets[j];
                let dist = Math.hypot(b.x - (boss.x+boss.size/2), b.y - (boss.y+boss.size/2));
                if (dist < boss.size/2 + b.size) {
                    boss.hp -= 10; // 100 hits to kill
                    bullets.splice(j, 1);
                    updateBossHud();
                    if (boss.hp <= 0) victory();
                }
            }

            // Boss Collision with Player Body
             let pDist = Math.hypot((player.x+player.size/2) - (boss.x+boss.size/2), (player.y+player.size/2) - (boss.y+boss.size/2));
            if (pDist < (boss.size/2 + player.size/2)) {
                player.health -= 1; // Constant damage if touching boss
                updateHud();
                if (player.health <= 0) gameOver();
            }
        }

        // 7. BOSS BULLETS
        for (let i = bossBullets.length - 1; i >= 0; i--) {
            let bb = bossBullets[i];
            bb.x += bb.dx;
            bb.y += bb.dy;
            
            // Hit Player?
            let dist = Math.hypot((player.x+player.size/2) - bb.x, (player.y+player.size/2) - bb.y);
            if (dist < (player.size/2 + bb.size)) {
                player.health -= 20; // Heavy Damage
                bossBullets.splice(i, 1);
                updateHud();
                if (player.health <= 0) gameOver();
            }
            // Cleanup
            if (bb.x < 0 || bb.x > canvas.width || bb.y < 0 || bb.y > canvas.height) bossBullets.splice(i, 1);
        }
    }

    function spawnEnemy() {
        let ex, ey;
        if (Math.random() < 0.5) {
            ex = Math.random() < 0.5 ? 0 : canvas.width;
            ey = Math.random() * canvas.height;
        } else {
            ex = Math.random() * canvas.width;
            ey = Math.random() < 0.5 ? 0 : canvas.height;
        }
        enemies.push({
            x: ex, y: ey, size: 25, speed: 2 + (score/5000), color: '#00ccff'
        });
    }

    function spawnBoss() {
        bossSpawned = true;
        boss.active = true;
        boss.x = canvas.width / 2 - 40;
        boss.y = -100; // Drop from top
        document.getElementById('bossHud').style.display = 'block';
    }

    function updateHud() {
        document.getElementById('signalDisplay').innerText = "SIGNAL STRENGTH: " + Math.floor(player.health) + "%";
        document.getElementById('scoreDisplay').innerText = score;
    }

    function updateBossHud() {
        let pct = (boss.hp / boss.maxHp) * 100;
        document.getElementById('boss-hp-fill').style.width = pct + "%";
    }

    function gameOver() {
        gameRunning = false;
        document.getElementById('game-over').style.display = 'block';
    }

    function victory() {
        gameRunning = false;
        document.getElementById('victory').style.display = 'block';
        boss.active = false;
    }

    function draw() {
        ctx.fillStyle = '#050505'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Grid
        ctx.strokeStyle = '#001100';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i < canvas.width; i += 50) { ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); }
        for (let i = 0; i < canvas.height; i += 50) { ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); }
        ctx.stroke();

        if (!gameRunning) return;

        // Drops
        drops.forEach(d => {
            let pulse = Math.sin(frameCount * 0.1) * 3;
            ctx.shadowBlur = 15; ctx.shadowColor = '#ff0033'; ctx.fillStyle = '#ff0033';
            ctx.beginPath(); ctx.arc(d.x, d.y, d.size + pulse, 0, Math.PI * 2); ctx.fill();
        });

        // Player
        ctx.shadowBlur = 20; ctx.shadowColor = player.color; ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.size, player.size);

        // Enemies
        enemies.forEach(e => {
            ctx.shadowBlur = 10; ctx.shadowColor = e.color; ctx.fillStyle = e.color;
            ctx.fillRect(e.x, e.y, e.size, e.size);
        });

        // BOSS
        if (boss.active) {
            ctx.shadowBlur = 30; ctx.shadowColor = boss.color; ctx.fillStyle = boss.color;
            ctx.fillRect(boss.x, boss.y, boss.size, boss.size);
            
            // Boss Eye (Visual flair)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(boss.x + 20, boss.y + 20, 40, 10);
        }

        // Bullets (Player)
        bullets.forEach(b => {
            ctx.shadowBlur = 10; ctx.shadowColor = b.color; ctx.fillStyle = b.color;
            ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2); ctx.fill();
        });

        // Bullets (Boss)
        bossBullets.forEach(bb => {
            ctx.shadowBlur = 15; ctx.shadowColor = bb.color; ctx.fillStyle = bb.color;
            ctx.beginPath(); ctx.arc(bb.x, bb.y, bb.size, 0, Math.PI * 2); ctx.fill();
        });

        ctx.shadowBlur = 0;
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }
    loop();
</script>
</body>
</html>
